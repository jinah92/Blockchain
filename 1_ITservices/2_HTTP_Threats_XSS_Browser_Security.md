# (DAY 2) HTTP 인증방식, XSS, CSP

## MSA (MicroService Architecture)

---

- SOA (Service Oriented Architecure)의 경량화 버전
- 독립적으로 배포/확장될 수 있는 서비스들을 조합하여 큰 어플리케이션을 구성하는 아키텍처 패턴

## 보안 약점과 보안 취약점

---

- 보안 약점 ==> 원인
- 보안 취약점 ==> 실제 실현/결과

# HTTP

---

## HTTP 기본 인증 방식 **(HTTP Basic Authentication)**

---

[DAY%202%20HTTP%20XSS%20CSP/untitled](DAY%202%20HTTP%20XSS%20CSP/untitled)

- 단점
    - 인증정보를 Base64로 인코딩하여 전송 (==> 정보 유출)
    - 세션을 유지하지 않음
        - 매 요청시 해당 정보를 서버로 전달 (==> 인증정보 노출이 빈번하여 유출 가능성이 높아짐)
        - 따라서, "세션 유지"를 사용하는 인증방식을 사용해야 함 (Form-based Authentication)

## HTTP From-based Authentication (= 일반적인 로그인 방식)

---

- 인증정보가 인증을 처리할 때만 전달 (한번만 전달)
- 인증 처리 과정을 안전하게 구현(제공)하면 인증정보 노출을 막을 수 있다.
- 서버에서 사용자를 구분(식별)하는 세션 ID가 중요 ==> **세션ID의 생성 및 관리가 중요!!**

(클라이언트)                                                                            (서버)

ID : ___________ -------------------> `login.do?id=___________` (일치하는 정보를 조회)

PW : ___________ [Login]                  `&pw=___________` 

                                                        - 일치하는 정보가 존재하면 Session ID를 생성
    
                                                         -  사용자 관련 정보를 세션에 저장
    
                     `Set-cookie : SID=1234`
    
                        <-------------------
    
                     `Cookie : SID = 1234`
    
                         ------------------> 클라이언트가 전달한 세션ID를 이용해서 사용자를 식별, 서비스 제공

## HTTP 요청/응답 구조 & 보안공격

---

### HTTP 응답 구조

**[시작]
—————————————————————————————-**
 **POST** /openeg HTTP/1.1 ***\n(개행문자 = 줄바꿈 = CR+LF)** 
    ⇒* **방식** **URI(URL)** **프로토콜/버전

[헤더]
—————————————————————————————**
**Referer**: /abc.html \n
   ⇒ **요청이 발생한 위치(html 파일 위치) (활용) 순차적인 처리가 필요한 작업, CSRF 취약점 방어

Cookie:** role=user; \n
   ⇒ **서버로부터 부여받은 값을 서버로 전송

Content-Length:** 28 \n 
  ⇒ **요청 본문의 길이

Content-Type:** x-www-form-urlencoded \n
  ⇒  **본문 내용의 인코딩 방식**  **(** **multipart/form-data; 인코딩내용 >> 파라미터 구분을 인코딩내용으로 사용)**

\n
 ⇒ **요청헤더의 끝 (개행문자 2개가 연속)**

**[본문]** = 클라이언트가 서버에게 전달하는 내용 (==> 요청방식에 따라서 유무 결정)

**—————————————————————————————**

**(1) 방식 = method = 클라이언트가 서버에게 전달하는 명령어**

- GET : 서버에게 자원을 요청 , 요청 처리에 필요한 값을 **"주소"**에 포함해서 전달

- POST : 서버에게 자원을 요청 , 요청 처리에 필요한 값을 **"본문"**에 포함해서 전달

- OPTIONS : **서버가 제공하는 method**를 요청

- HEAD : 스케일링 목적으로 활용 (서버는 본문을 제외한 응답 메시지를 보냄), 서버에게 **자원의 '상태'**를 요청

- DELETE : 서버가 가지고 있는 자원의 **삭제** 요청

- PUT : 서버에게 본문의 내용 **생성**을 요청

**(2) URI = URL + URN 
⇒** 웹 상에서 서비스를 제공하는 각 서버들에 있는 파일들의 위치를 표시하기 위한 것
** URL : 네트워크 상에서 자원이 어디 있는지를 알려주기 위한 규약*

 http:// www.naver.com: 80 /subdir/file.html **?** parameter1=value1&parameter2=value2 **#**fragment

스킴 호스트 포트 경로및파일 파라미터 책갈피(문서내 위치)

**multipart/form-data**
파일과 같이 정형화되지 않은 자료를 서버로 전달할 때 설정하는 Content-Type 요청 헤더의 값

## **HTTP 요청 보안공격**

---

### **Rudy Attack (= HTTP Post Attack)**

- Content-length 보다 적은 길이(1btye씩)를 보내므로써 DoS를 유발하는 공격

### **Slowloris Attack**

- 의미없는 헤더를 보내서 (헤더의 끝 \n\n 을 보내지 않음) DoS를 유발하는 공격

## HTTP 응답 구조

---

**[시작]
—————————————————————————————-**

HTTP/1.1 200 OK \n
 ⇒  **프로토콜/버전** **상태코드** **상태 설명**

**[헤더]
—————————————————————————————-**

Set-Cookie : role=user \n
 ⇒ **쿠키를 설정**

Location: main.do \n 

 ⇒ **리다이렉트할 주소를 설정**

Content-Type: text/html \n 

 ⇒ **본문의 인코딩 방식을 설정**

Content-Length: 2048 \n  ****

 ⇒ **본문의 길이**

\n 

 ⇒ **응답헤더의 끝 (개행문자 2개가 연속)**

**[본문]
—————————————————————————————-**

<html><head> ... </head><body>...</body></html>

## HTTP 응답 분할 공격

---

- **외부 입력값에 개행문자(CSRF) 포함 여부를 확인하지 않고 응답헤더의 값으로 사용하는 경우 발생하는 공격**

    ⇒ 응답이 여러개로 분할되어 브라우저로 전달

    ⇒ 분할된 응답의 본문 영역에 실행가능한 코드를 삽입하여 사용자 브라우저를 실행

시작   HTTP/1.1 200 OK \n

헤더   Set-Cookie : role=user \n

    Location: **main.do \n ... \n\n ...<script></script>... \nHTTP/1.1 200 OK \n ...** \n
    
    Content-Type: text/html \n
    
    Content-Length: 2048 \n  ****
    
    \n

본문 <html><head> ... </head><body>...</body></html>

**→ 응답 헤더의 값으로 사용하는 경우**

1. 쿠키
2. 리다이렉트
3. setHeader

**→ 방어기법 : 개행문자를 필러링하고, 외부 입력값을 사용**

## **상태코드**

---

- 1xx : 정보

- 2xx : 성공

- 3xx : 리다이렉트 또는 포워드

- 4xx : Client side error

- 5xx : Server side error

## 파일 업로그 기능 구현 시 유의사항

---

- **파일의 크기와 개수를 제한** → 서버의 '연결 자원' 또는 '디스크 자원'을 고갈시켜, 정상적인 서비스를 방해 (Dos, DDoS)
- **파일의 종류를 제한** → (A) 서버에서 실행 가능한 파일이 업로드되면, 해당 파일을 실행하여 서버의 제어권을 탈취하거나 악성코드의 유포지로 악용될 수 있음 (서버 제어권 탈취, 악성코드)
- **(A) 상황을 방어하기 위해서는,** **①파일은 외부에서 접근할 수 없는 경로에 저장해야 함 / ②업로드 파일의 저장경로와 파일명을 외부에서 알 수 없도록 처리 / ③업로드 파일의 실행 속성을 제거 후 저장**

## 리다이렉트 (Redirect)

---

- 요청을 다른 요청으로 변경하는 것
- **Open Redirect**
    - 리다이렉트 기능이 제공될 때, 외부 입력값을 검증 및 제한하지 않고 리다이렉트 주소로 사용하는 경우 발생하는 공격
    - 의도하지 않은 사이트로 리다이렉트가 발생
    - '피싱'과 같은 공격에 악용됨

- **HTTP 프로토콜**을 이용한 리다이렉트 ⇒ 최우선순위 (HTML 헤더)

login GET /login.do?id=aaa&pw=bbb HTTP/1.1

ID: ______ -------------------------------------------------------> login.do <--- DB 조회 --->

PW: _____ HTTP/1.1 200 OK

<------------------------------------------------------ (일치하는 결과가 있으면)

HTTP/1.1 302 Move Temprory

Location: main.do

<------------------------ <--------------------------- (일치하는 결과가 없으면)

| GET /main.do HTTP/1.1

-------------------------->---------------------------> main.do

HTTP/1.1 200 OK |

main <-------------------------<----------------------------

- **HTML 메타 태그**를 이용한 리다이렉트 ⇒  2순위 (HTML 바디)

<meta http-equiv="refresh" content="0;url=login.do">

<**Javascript**를 이용한 리다이렉트> ==> 3순위 (HTML 바디)

<script>

location.href = "________";

</script>

## 포워드 (Forward)

---

- 서버 내부적으로 리다이렉트한 후, 클라이언트에게 응답
- 최초 요청을 최종 화면에 활용 (최초 요청시의 주소가 최종 화면에도 그대로 표시)

login GET /login.do?id=aaa&pw=bbb HTTP/1.1

ID: ______ -------------------------------------------------------> login.do <--- DB 조회 --->

PW: _____                                                    | HTTP/1.1 200 OK | 일치하는 결과가 있으면)

        main <-----------------------------------------------------+ main. do

## 브라우저 보안기능

---

- **기원, 출처 (= origin) =** **스킴** **+** **호스트** **+** **포트**
    - (1) http://www.naver.com/path/file
    - (2) http://www.naver.com/theotherpath/theotherfile
    - (3) http://mail.naver.com:8445/path/file * (1)과 (2)는 동일 기원, (3)은 (1)과 기원이 다름
- **교차 기원 요청**
    - 웹은 교차 기원 요청이 가능하다. (Cross Origin Request)
    - 즉, 웹에서는 다른 사이트에서 제공하는 이미지, 스크립트 같은 코드를 가져와서 사용이 가능하다.
- **Javascript를 이용해서 자원을 가져오는 경우는,** **동일 기원에 대해서만 사용할 수 있도록 허용한다.**
    - SOP(Same Origin Policy) : 동일 기원(출처) 정책
    - CORS(Cross-Origin Resource Sharing, 교차 기원 자원 공유) : SOP 정책을 완화 / 다른 웹페이지에 있는 리소스를 사용하는 것

        ==> 서버측에서 자원의 사용여부를 헤더로 알려줌

- **CSP (Content Security Policy) = 콘텐츠 보안 정책**
    
    - 브라우저에 특정 리소스 세트를 허용 가능한 것으로 처리하고 나머지는 거부하도록 명백히 지시하는 방법

## XSS **(Cross-Site Scripting)**

---

- 공격자가 전달한 스크립트 코드가 사용자 브라우저를 통해서 실행
    - 사용자 브라우저 또는 PC의 정보를 탈취
    - 가짜 페이지를 만들고, 사용자 입력을 유도해서 정보를 탈취
    - 원격지에서 해당 PC의 조정이 가능 (= 제어권 탈취) ==> BeEF
- **반사 XSS = Reflective XSS (서버를 경유, 서버에 남아있지는 않음)**

    요청이 다음 화면 출력을 위해서 사용되는 경우 발생

    ID 중복체크

    ID : **abc** [search] --------> search.jsp?id=**abc**

    **'abc'**는 존재 ... <-------- "<%=request.getParameter("id")%>"는 존재…

    아래와 같은 공격문자열을 만들어서 불특정 다수에게 메일 또는 sns 등의 방식으로 전파

    <a href="http://localhost:8080/openeg/redirect.jsp?**id=abc<script>alert('xss')</script>**">...</a>

- **#2. 저장 XSS = Stored XSS (서버에 남아있음)**

    공격자가 전달한 스크립트 코드가 취약한 서버에 저장되고, 지속적으로 사용자에게 전달되는 경우 (게시판)

    공격자(글쓰기)         -----------------------> 글저장 (DB) <script>...</script> <script>...</script>

                                                                         |

    희생자(글보기) <----------------------------+

    <script>...</script>