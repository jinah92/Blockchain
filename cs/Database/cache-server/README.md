# 캐시 서버의 개념 및 사용목적

초기 서비스의 운영할 때에는 WEB-WAS-DB의 전형적인 3티어 구조를 사용하게 된다. 하지만 사용자의 수가 늘어날수록, 매 트랜잭션 시마다 디스크에 접근하게 되어 부하가 늘어나게 되는 문제점이 있다.

> 사용자가 늘어나면서, **캐시서버**를 도입하게 된다
> 

DB만으로 부하를 견딜 수 없다면 캐시서버의 도입을 생각해야 한다. 여기서 **캐시(Cache)**란, **한 번 들어온 데이터를 임의의 공간에 저장하여 다음에 읽을 때는 빠르게 결과값을 받을 수 있도록 도와주는 공간**이다. 

- cache hit : 캐시서버에 데이터가 있으면, DB에 요청하지 않고 바로 클라이언트에 데이터를 반환
- cache miss : 캐시서버에 데이터가 없으면, DB에 해당 데이터를 요청

또한 **동시다발적으로 쓰기가 발생하는 경우**에, 캐시서버 도입을 생각하게 된다.

클라이언트는 웹 서버에 쓰기 요청을 하고, 웹 서버는 캐시에 데이터를 쓴 후 결과를 리턴한다. 워커 서버들은 캐시서버에 있는 데이터를 가져와서 작업을 수행하고, DB에 써서 순차적으로 트랜잭션을 처리하게 된다.

> 물론, 단점도 존재한다
> 

캐시서버는 속도를 위해 **주로 메모리를 사용하기 때문에, 서버에 장애가 나면 메모리가 날라가서 데이터가 손실**될 수 있다. 디스크를 사용하거나 replication을 구성해서 고가용성을 확보하기도 하지만, 속도가 상대적으로 떨어지거나 추가적인 비용이 발생할 수 있다.

<br />

# Redis

> **키-값(key-value) 기반의 인-메모리 데이터 저장소**
> 

키-값 기반이기 때문에 별도의 쿼리 없이 결과를 바로 가져올 수 있다. 또한 디스크에 데이터를 쓰는 구조가 아니라 메모리에서 데이터를 처리하기 때문에 속도가 상당히 빠르다.

Redis에서는 다양한 **데이터 구조(Collection)**을 제공한다.

- Strings : 단순한 키-값 매핑 구조
- Lists : Array 형식의 데이터 구조. 처음과 끝에 데이터를 넣고 빼는 것은 속도가 빠르다.
- Sets : 순서가 없는 Strings 데이터 집합. 중복된 데이터는 하나로 처리한다.
- Sorted Sets : Sets와 같은 구조이나, Score를 통해서 순서를 정할 수 있다. Leaderboard와 같은 기능을 손쉽게 구현 가능하다
- Hashes : 키-값의 구조를 여러개 가진 object 타입을 저장하기 좋은 구조

Redis는 다양한 용도로 사용된다. (캐시 데이터 및 인증토큰 저장, Ranking Board 등)

> **Redis 관리방법**
> 

Redis는 **싱글 스레드(Single threaded)** 방식이다. 즉, 한 번에 하나의 명령어만 실행이 가능하다. 만약 명령어를 포함한 패킷이 MTU보다 크면 패킷이 쪼개져서 올 수 있고, Redis는 쪼개진 명령어를 합쳐서 하나의 명령어로 만들어 실행한다.

평균적으로 **Get/Set 명령어의 경우 초당 10만개 정도까지 처리**할 수 있다. 단, **처리시간이 긴 명령어를 중간에 넣으면, 뒤에 있는 명령어들은 전부 기다려야 한다.**

Redis를 사용하여 서비스를 운영하면 메모리에 한계에 도달할 수 있다. 메모리의 한계는 **maxmemory 값으로 설정**할 수 있고, 해당 수치까지 메모리가 다 차는 경우 Redis는 **mex-memory-policy에 따라서 추가 메모리를 확보**한다.

maxmemory-policy 설정값

- noeviction : 기존 데이터를 삭제하지 않는다. 메모리가 꽉 찬 경우 OOM(Out Of Memory) 오류를 반환하고 새로운 데이터는 버린다.
- allkeys-lru : LRU(Least Recently Used)라는 페이지 교체 알고리즘을 통해 데이터를 삭제하여 공간을 확보한다.
- volatile-lru : expire set을 가진 것 중 LRU로 삭제하여 메모리 공간을 확보한다.
- allkeys-random : 랜덤으로 데이터를 삭제하여 공간을 확보한다.
- volatile-random : expire set을 가진 것 중 랜덤으로 데이터를 삭제하여 공간을 확보한다.
- volatile-ttl : expire set을 가진 것 중 TTL(Time To Live)값이 짧은 것부터 삭제한다.
- allkeys-lfu : 가장 적게 액세스한 키를 제거하여 공간을 확보한다.
- volatile-lfu : expire set을 가진 것 중 가장 적게 액세스한 키를 제거하여 공간을 확보한다.