# IT 서비스와 보안 (DAY 3)

### 1. 세션

**세션 ID**

- **세션ID '추측'**  ==> '생성 규칙'을 유추할 수 없어야 한다 (자바의 경우 API가 제공되지 않아 해당 공격이 불가능)
- **세션ID '고정'** (인증 전후, 동일한 세션ID가 유지) ==> 다른사람의 권한을 탈취. 따라서 인증 전후에는 세션ID가 달라야 한다
- **세션ID 탈취방법**
    - (네트워크)스니핑 : 네트워크 중간에서 패킷을 통해 세션ID를 획득
    - XSS : 클라이언트(브라우저) 단에서 세션ID를 획득
- **세션ID 탈취 방어기법**
    - 네트워크 구간 암호화 : HTTPS
    - XSS 완화
        - (입력) 입력값 검증 : 스크립트 입력 방지 또는 안전한 형태의 스크립트 값으로 변경하여 실행 및 저장
        - (출력) HTML 인코딩 : 브라우저에서 유의미한 코드를 무의미하도록 처리 (이스케이프 - 특별한 규칙을 이용한 방법)

            ※ 이스케이프 방법 : 이스케이프 문자를 활용하는 방법, 특별한 규칙을 이용한 방법

        - **출력방법이 더 중요하다! 예상치 못한 경로에서의 입력값에 대한 대응이 가능하기 때문! (안전하게 나간다)**
        - **XSS 방어가 어려운 이유 : 선별적인 적용이 필요**
        

### 2. 아스키코드

- **아스키코드(ASCII)** : 7bit, 128개
    - 가시적인 문자(95개) - 영대소문자, 숫자, 특수문자
    - 비가시적인 문자(33개) = 제어문자 또는 비인쇄문자
      

### 3. 스크립트 코드

- **스크립트 코드의 위험성**
    - **다양한 경로를 통해 실행**될 수 있다. (스크립트 태그, url, 이미지 태그 등)
    - **다양한 변형**으로 공격에 이용될 수 있다.
    

### 4. CSP

- **CSP (콘텐츠 보안 정책, Content Security Policy)**
    - 모질라가 개발한 표준소스
    - 브라우저에서 XSS 방어가 목표
        - XSS 공격은 브라우저가 어플리케이션에 속한 스크립트와 제3자가 악의적으로 주입한 스크립트를 구분하지 못한다는 문제점을 악용
        - 서버에서 제공하는 모든 것을 맹목적으로 신뢰하는 대신, 신뢰할 수 있는 콘텐츠 소스의 허용 목록(화이트리스트)를 생성할 수 있게 해주는 Content-Security-Policy HTTP 헤더를 정의
            - 입력값 제한 : 허용목록(화이트리스트) / 제한목록(블랙리스트)
            - 허용목록의 장단점 : 꾸준한 업데이트가 필요함/번거로움, 상대적으로 높은 보안성
        - 브라우저에서는 이런 소스에서 받은 리소스만 실행하거나 렌더링할 것을 지시함
    - (예시) Content-Security-Policy: script-src 'self' https://apls.google.com
        - 브라우저는 현재 페이지의 출처뿐 아니라, HTTPS를 통해 apis.goolge.com에서 제공되는 자바스크립트만 다운로드해 사용
        - 정의되지 않은 출처의 코드에 대해서는 오류가 발생
- CSP 지시문 : 허용되는 리소스를 세분화하여 제어할 수 있는 다양한 정책 지시문을 제공
  
    - Default-src : -src로 끝나는 모든 지시문의 기본 동작을 재정의
- 소스 목록 : 유연하게 작성 가능
    - 구성표(data:, https:)를 기준으로 지정
    - 호스트 이름으로 지정
    - 정규화된 url 사용
    - 범위를 특정하여 지정
- 메타 태그로 마크업하여, 페이지에 대한 정책을 직접 설정이 가능 (CSP 기본 전송 메커니즘은 HTTP 헤더)
- nonce를 이용한 인라인코드 사용
    - 원칙적으로는 인라인코드는 유해한 것으로 간주함
    - CSP level 2는 암호화 논스(한번 사용되는 숫자) 또는 해시를 사용하여 특정 인라인 스크립트를 허용목록에 추가하도록 허용
      

### 4. 해쉬

- **해쉬(Hash = Message Digest)**
    - **[임의의 입력값 ==> 고정길이의 출력값]** 으로 만드는 암호화 함수
    - 좋은 해쉬 알고리즘의 특징
        - **유일성** ==> **"무결성' ※ 정보보호의 3요소 - 기밀성/무결성/가용성**
        - **단방향성** ==> **"인증정보 저장 및 처리"** ※ **PW는 반드시 단방향 해쉬함수로 암호화 (개인정보보호법, 정보통신망법)**
            - 양방향 암호화 : **"동일한 키(KEY)"**를 사용하여 암호화 **(핵심요소 : KEY)**
            - 비도 (= 보안강도) : 효휼성 측면에서, 일반적으로 적정선을 유지해야 함 (비도와 키 길이 : "비례")
        - **빠른 연산**
        - **충돌 회피**
    - **해쉬 크래킹**
        - **사전 대입 공격**
        - **무작위 대입 공격**
        - **레인보우 테이블**
    - **해쉬 크래킹 방어 기법**
        - **입력값의 경우의 수 ↑**
        - **입력값의 길이 ↑ ( = salt 삽입)**
    - **블록체인 : SHA-3**



### 5. 인코딩/디코딩

- 규칙에 따라, "대체/치환" 또는 "전위" (현재는 쉽게 깨지므로, 암복호화로서 사용해서는 안됨)